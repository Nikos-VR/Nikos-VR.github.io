<!DOCTYPE html>
<html lang="el">

<head>
    <meta charset="UTF-8">
    <title>Js Online SEq</title>
    <style>
        ::-webkit-scrollbar {
            width: 9px;
            height: 9px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #d4d4d4;
            border-radius: 10px;
        }

        body {
            font-family: sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }

        .controls-panel {
            font-size: 20px;
        }

        button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            color: white;
            border: none;
            font-size: 25px;
        }

        button:disabled {
            color: silver;
            cursor: not-allowed;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 1px;
            vertical-align: middle;
            width: 75px;
            margin-right: 25px;
            background: white;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            cursor: pointer;
            background: silver;
            border-radius: 5px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 10px;
            height: 10px;
            cursor: pointer;
            background: silver;
        }

        #sequencer-container {
            display: flex;
            flex-direction: column;
            overflow: auto;
        }

        .track {
            display: flex;
            align-items: center;
        }

        .track-ui-container {
            display: flex;
            flex-direction: column;
            background-color: #2a2a2a;
            padding: 9px;
            border-bottom: dotted silver 1px;
        }

        .track-controls {
            display: flex;
            align-items: center;
        }

        .track-controls button {
            padding: 4px 8px;
            font-size: 12px;
        }

        .record-btn {
            border: solid firebrick 1px;
            border-radius: 15px;
        }

        .record-btn.recording {
            color: firebrick;
        }

        .track-label {
            font-size: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 90px;
            padding-left: 1px;
        }

        .trim-controls {
            display: flex;
            align-items: center;
            gap: 3px;
            margin-top: 5px;
        }

        .trim-controls label {
            font-size: 10px;
        }

        .trim-controls input[type="range"] {
            margin-right: 5px;
            width: 20px;
        }

        .effect-selector {
            font-size: 11px;
            width: 80px;
            margin-left: 40px;
        }

        .grid-row {
            display: flex;
        }

        .cell {
            width: 50px;
            height: 59px;
            background-color: #444;
            border: 1px solid #555;
            cursor: pointer;
        }

        .cell.active {
            background-color: cadetblue;
        }

        .cell.measure-divider {
            border-right: 3px solid goldenrod;
        }

        .cell.playback-head {
            background-color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>

<body>
    <div style="float:left; margin:20px; margin-right: 105px; opacity: 0.75;"><strong>J</strong><small>avascript</small> <strong>O</strong><small>nline</small> <strong>SE</strong><small>quencer</small></div>
    <div class="controls-panel" style="float:right">
        <label for="tempo-slider">&#9833;</label>
        <input type="range" id="tempo-slider" min="30" max="360" value="120" title="120 BPM">
        <label for="time-signature-slider">&#119066;</label>
        <input type="range" id="time-signature-slider" min="2" max="7" value="4" title="4/4">
        <label for="rows-slider">&#127929;</label>
        <input type="range" id="rows-slider" min="1" max="25" value="8" title="8 tracks">
        <label for="cols-slider">&#9202;</label>
        <input type="range" id="cols-slider" min="4" max="128" value="64" title="32 secs">
    </div>
    <div class="controls-panel">
        <button id="play-btn" style="color:darkolivegreen" title="Play">&#9654;</button>
        <button id="pause-btn" style="color:goldenrod" title="Pause" disabled>&#9208;</button>
        <button id="stop-btn" style="color:cadetblue" title="Stop">&#9724;</button>
        <button id="download-btn" style="color:firebrick" title="Download">&#8681;</button>
    </div>
    <br>
    <div id="sequencer-container"></div>

    <script>
        window.addEventListener('load', () => {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const dom = {
                playBtn: document.getElementById('play-btn'),
                pauseBtn: document.getElementById('pause-btn'),
                stopBtn: document.getElementById('stop-btn'),
                downloadBtn: document.getElementById('download-btn'),
                tempoSlider: document.getElementById('tempo-slider'),
                timeSignatureSlider: document.getElementById('time-signature-slider'),
                rowsSlider: document.getElementById('rows-slider'),
                colsSlider: document.getElementById('cols-slider'),
                sequencerContainer: document.getElementById('sequencer-container'),
            };

            let state = {
                tempo: 120, timeSignature: 4, numRows: 8, numCols: 64,
                isPlaying: false, currentStep: 0, scheduler: null,
                grid: [], tracks: [], cells: [],
                mediaRecorder: null, recordingTrackIndex: null
            };

            function playSound(track) {
                if (!track || !track.buffer || audioContext.state === 'suspended') return;
                const source = audioContext.createBufferSource();
                source.buffer = track.buffer;
                source.connect(track.gain);

                const offset = track.trimStart;
                const duration = track.trimEnd - track.trimStart;

                if (duration > 0) {
                    source.start(0, offset, duration);
                }
            }

            async function processAudioBuffer(arrayBuffer, rowIndex, fileName = 'Recorded Sample') {
                try {
                    const buffer = await audioContext.decodeAudioData(arrayBuffer);
                    const gainNode = audioContext.createGain();
                    const panner = new PannerNode(audioContext, {
                        panningModel: 'HRTF', distanceModel: 'inverse',
                        positionX: 0, positionY: 0, positionZ: 0
                    });

                    const delayNode = audioContext.createDelay(1.0);
                    delayNode.delayTime.value = 0.5;
                    const feedbackNode = audioContext.createGain();
                    feedbackNode.gain.value = 0.5;
                    delayNode.connect(feedbackNode);
                    feedbackNode.connect(delayNode);

                    const flangerDelay = audioContext.createDelay(1.0);
                    flangerDelay.delayTime.value = 0.005;
                    const flangerFeedback = audioContext.createGain();
                    flangerFeedback.gain.value = 0.5;
                    const flangerLFO = audioContext.createOscillator();
                    flangerLFO.type = 'sine';
                    flangerLFO.frequency.value = 0.5;
                    const flangerLfoGain = audioContext.createGain();
                    flangerLfoGain.gain.value = 0.005;
                    flangerLFO.connect(flangerLfoGain);
                    flangerLfoGain.connect(flangerDelay.delayTime);
                    flangerLFO.start();
                    flangerDelay.connect(flangerFeedback).connect(flangerDelay);

                    const convolverNode = audioContext.createConvolver();
                    const impulseSeconds = 2.5;
                    const impulseBuffer = audioContext.createBuffer(2, audioContext.sampleRate * impulseSeconds, audioContext.sampleRate);
                    for (let i = 0; i < impulseBuffer.numberOfChannels; i++) {
                        const channel = impulseBuffer.getChannelData(i);
                        for (let j = 0; j < impulseBuffer.length; j++) {
                            channel[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / impulseBuffer.length, 2);
                        }
                    }
                    convolverNode.buffer = impulseBuffer;

                    const distortionNode = audioContext.createWaveShaper();
                    const amount = 250;
                    const curve = new Float32Array(22050);
                    for (let i = 0; i < 22050; i++) {
                        const x = i * 2 / 22050 - 1;
                        curve[i] = (x < 0) ? (x * (1 + amount * x)) : (x / (1 + amount * x));
                    }
                    distortionNode.curve = curve;
                    distortionNode.oversample = '4x';

                    const filterNode = audioContext.createBiquadFilter();
                    filterNode.type = 'bandpass';
                    filterNode.frequency.value = 5000;
                    filterNode.Q.value = 1;

                    const tremoloGain = audioContext.createGain();
                    tremoloGain.gain.value = 1;
                    const tremoloLFO = audioContext.createOscillator();
                    tremoloLFO.type = 'sine';
                    tremoloLFO.frequency.value = 5;
                    const tremoloLfoGain = audioContext.createGain();
                    tremoloLfoGain.gain.value = 0.5;
                    tremoloLFO.connect(tremoloLfoGain);
                    tremoloLfoGain.connect(tremoloGain.gain);
                    tremoloLFO.start();

                    state.tracks[rowIndex] = {
                        buffer: buffer,
                        name: fileName,
                        trimStart: 0,
                        trimEnd: buffer.duration,
                        gain: gainNode,
                        panner: panner,
                        panX: 0, panY: 0, panZ: 0,
                        activeEffect: 'no-fx',
                        fxA: 50, fxB: 50,
                        effects: {
                            delay: { main: delayNode, feedback: feedbackNode },
                            flanger: { main: flangerDelay, feedback: flangerFeedback },
                            reverb: { main: convolverNode },
                            distortion: { main: distortionNode },
                            filter: { main: filterNode },
                            tremolo: { main: tremoloGain, lfo: tremoloLFO, gain: tremoloLfoGain }
                        }
                    };
                    updateTrackAudioChain(rowIndex);
                    updateTrackUI(rowIndex);
                } catch (error) { console.error('Error decoding audio data', error); }
            }

            function updateTrackAudioChain(rowIndex) {
                const track = state.tracks[rowIndex];
                if (!track) return;

                track.gain.disconnect();
                Object.values(track.effects).forEach(effect => function () { effect.main.disconnect(); effect.feedback.disconnect(); });

                const effect = track.effects[track.activeEffect];
                const sliderA = document.getElementById('fxA-' + rowIndex);
                const sliderB = document.getElementById('fxB-' + rowIndex);

                if (track.activeEffect === 'no-fx' || !effect) {
                    track.gain.connect(track.panner).connect(audioContext.destination);
                }
                else if (track.activeEffect === 'delay') {
                    effect.main.delayTime.value = track.fxA / 100.0;
                    effect.feedback.gain.value = track.fxB / 100.0;
                    track.gain.connect(track.panner).connect(audioContext.destination);
                    track.gain.connect(effect.main);
                    effect.main.connect(effect.feedback);
                    effect.main.connect(track.panner);
                    sliderA.title = 'Delay: ' + (track.fxA / 100.0) + 's';
                    sliderB.title = 'Gain: ' + (track.fxB / 100.0);
                }
                else if (track.activeEffect === 'flanger') {
                    effect.main.delayTime.value = track.fxA / 10000.0;
                    effect.feedback.gain.value = track.fxB / 100.0;
                    track.gain.connect(track.panner).connect(audioContext.destination);
                    track.gain.connect(effect.main);
                    effect.main.connect(effect.feedback).connect(effect.main);
                    effect.main.connect(track.panner);
                    sliderA.title = 'Delay: ' + (track.fxA / 10000.0) + 's';
                    sliderB.title = 'Feedback: ' + (track.fxB / 100.0);
                }
                else if (track.activeEffect === 'reverb') {
                    const impulseBuffer = audioContext.createBuffer(2, audioContext.sampleRate * track.fxA / 20.0, audioContext.sampleRate);
                    for (let i = 0; i < impulseBuffer.numberOfChannels; i++) {
                        const channel = impulseBuffer.getChannelData(i);
                        for (let j = 0; j < impulseBuffer.length; j++) {
                            channel[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / impulseBuffer.length, 2);
                        }
                    }
                    effect.main.buffer = impulseBuffer;
                    sliderA.title = 'Impulse: ' + (track.fxA / 20.0) + 's';
                    sliderB.title = 'Gain: ' + (track.fxB / 50.0);
                    track.gain.gain.value = track.fxB / 50.0;
                    track.gain.connect(effect.main).connect(track.panner).connect(audioContext.destination);
                }
                else if (track.activeEffect === 'distortion') {
                    const curve = new Float32Array(22050);
                    for (let i = 0; i < 22050; i++) {
                        const x = i * 2 / 22050 - 1;
                        curve[i] = (x < 0) ? (x * (1 + track.fxA * 5.0 * x)) : (x / (1 + track.fxA * 5.0 * x));
                    }
                    effect.main.curve = curve;
                    sliderA.title = 'Amount: ' + (track.fxA * 10.0);
                    sliderB.title = 'Gain: ' + (track.fxB / 100.0);
                    track.gain.gain.value = track.fxB / 100.0;
                    track.gain.connect(effect.main).connect(track.panner).connect(audioContext.destination);
                }
                else if (track.activeEffect === 'filter') {
                    effect.main.frequency.value = track.fxA * 100.0;
                    sliderA.title = 'Frequency: ' + (track.fxA * 100.0) + 'Hz';
                    sliderB.title = 'Gain: ' + (track.fxB / 50.0);
                    track.gain.gain.value = track.fxB / 50.0;
                    track.gain.connect(effect.main).connect(track.panner).connect(audioContext.destination);
                }
                else if (track.activeEffect === 'tremolo') {
                    effect.lfo.frequency.value = track.fxA / 10.0;
                    effect.gain.gain.value = track.fxB / 100.0;
                    sliderA.title = 'Frequency: ' + (track.fxA / 10.0) + 'Hz';
                    sliderB.title = 'LFO Gain: ' + (track.fxB / 100.0);
                    track.gain.connect(effect.main);
                    effect.main.connect(track.panner).connect(audioContext.destination);
                }
            }

            function updateGrid() {
                const oldGrid = [...state.grid];
                const oldTracks = [...state.tracks];

                dom.sequencerContainer.innerHTML = '';
                state.grid = [];
                state.cells = [];
                state.tracks = [];

                for (let row = 0; row < state.numRows; row++) {
                    state.grid[row] = [];
                    state.cells[row] = [];
                    state.tracks[row] = oldTracks[row] || null;

                    const trackDiv = document.createElement('div');
                    trackDiv.className = 'track';
                    const uiContainer = document.createElement('div');
                    uiContainer.className = 'track-ui-container';
                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'track-controls';

                    const label = document.createElement('span');
                    label.id = `track-label-${row}`;
                    label.className = 'track-label';
                    label.textContent = `Track ${row + 1}`;

                    const previewBtn = document.createElement('button');
                    previewBtn.id = `preview-btn-${row}`;
                    previewBtn.innerHTML = '&#9654;';
                    previewBtn.disabled = true;
                    previewBtn.onclick = () => playSound(state.tracks[row]);
                    previewBtn.title = "Preview";

                    const uploadInput = document.createElement('input');
                    uploadInput.type = 'file';
                    uploadInput.accept = 'audio/*';
                    uploadInput.style.display = 'none';
                    uploadInput.onchange = (e) => loadSample(e.target.files[0], row);

                    const uploadBtn = document.createElement('button');
                    uploadBtn.innerHTML = '&#x1F4C2;';
                    uploadBtn.onclick = () => uploadInput.click();
                    uploadBtn.title = "Upload";

                    const recordBtn = document.createElement('button');
                    recordBtn.id = `record-btn-${row}`;
                    recordBtn.className = 'record-btn';
                    recordBtn.innerHTML = '&#9210;';
                    recordBtn.onclick = () => handleRecordClick(row);
                    recordBtn.title = "Record";

                    const effectSelector = document.createElement('select');
                    effectSelector.id = `effect-selector-${row}`;
                    effectSelector.className = 'effect-selector';
                    effectSelector.disabled = true;
                    ['No-FX', 'Delay', 'Flanger', 'Reverb', 'Distortion', 'Filter', 'Tremolo'].forEach(effectName => {
                        const option = document.createElement('option');
                        option.value = effectName.toLowerCase();
                        option.textContent = effectName;
                        effectSelector.appendChild(option);
                    });
                    effectSelector.onchange = (e) => {
                        state.tracks[row].activeEffect = e.target.value;
                        updateTrackAudioChain(row);
                    };

                    controlsDiv.append(previewBtn, label, uploadBtn, recordBtn, uploadInput, effectSelector);

                    const trimDiv = document.createElement('div');
                    trimDiv.className = 'trim-controls';

                    const startLabel = document.createElement('label'); startLabel.textContent = 'S';
                    const startSlider = document.createElement('input');
                    startSlider.type = 'range'; startSlider.id = `start-slider-${row}`; startSlider.disabled = true;
                    startSlider.min = 0; startSlider.max = 1; startSlider.step = 0.01;
                    startSlider.oninput = (e) => handleTrimChange(row, 'start', parseFloat(e.target.value));
                    startSlider.title = "Start";

                    const endLabel = document.createElement('label'); endLabel.innerHTML = 'E';
                    const endSlider = document.createElement('input');
                    endSlider.type = 'range'; endSlider.id = `end-slider-${row}`; endSlider.disabled = true;
                    endSlider.min = 0; endSlider.max = 1; endSlider.step = 0.01;
                    endSlider.oninput = (e) => handleTrimChange(row, 'end', parseFloat(e.target.value));
                    endSlider.title = "End";

                    const gap1 = document.createElement('span');
                    gap1.style.width = '10px';
                    const gap2 = document.createElement('span');
                    gap2.style.width = '10px';

                    trimDiv.append(startLabel, startSlider, endLabel, endSlider, gap1);

                    ['X', 'Y', 'Z'].forEach(axis => {
                        const label = document.createElement('label');
                        label.textContent = axis;
                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.className = 'pan-controls';
                        slider.id = `pan${axis}-slider-${row}`;
                        slider.min = -10; slider.max = 10; slider.step = 1; slider.value = 0;
                        slider.oninput = (e) => handlePanChange(row, axis, parseFloat(e.target.value));
                        trimDiv.append(label, slider);
                    });
                    const effectLabelA = document.createElement('label');
                    effectLabelA.textContent = 'A';
                    effectLabelA.style.marginLeft = '5px;';
                    const effectSliderA = document.createElement('input');
                    effectSliderA.type = 'range';
                    effectSliderA.className = 'effect-controls';
                    effectSliderA.id = `fxA-${row}`;
                    effectSliderA.min = 1; effectSliderA.max = 100; effectSliderA.step = 1; effectSliderA.value = 50;
                    effectSliderA.oninput = (e) => handleFXChange(row, true, parseFloat(e.target.value));
                    trimDiv.append(gap2, effectLabelA, effectSliderA);
                    const effectLabelB = document.createElement('label');
                    effectLabelB.textContent = 'B';
                    const effectSliderB = document.createElement('input');
                    effectSliderB.type = 'range';
                    effectSliderB.className = 'effect-controls';
                    effectSliderB.id = `fxB-${row}`;
                    effectSliderB.min = 1; effectSliderB.max = 100; effectSliderB.step = 1; effectSliderB.value = 50;
                    effectSliderB.oninput = (e) => handleFXChange(row, false, parseFloat(e.target.value));
                    trimDiv.append(effectLabelB, effectSliderB);

                    uiContainer.append(controlsDiv, trimDiv);

                    const gridRowDiv = document.createElement('div');
                    gridRowDiv.className = 'grid-row';
                    for (let col = 0; col < state.numCols; col++) {
                        const wasActive = oldGrid[row] ? oldGrid[row][col] : false;
                        state.grid[row][col] = wasActive;

                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        if (wasActive) cell.classList.add('active');
                        if ((col + 1) % state.timeSignature === 0) cell.classList.add('measure-divider');

                        cell.onclick = () => {
                            state.grid[row][col] = !state.grid[row][col];
                            cell.classList.toggle('active', state.grid[row][col]);
                        };
                        state.cells[row][col] = cell;
                        gridRowDiv.appendChild(cell);
                    }

                    trackDiv.append(uiContainer, gridRowDiv);
                    dom.sequencerContainer.appendChild(trackDiv);

                    if (state.tracks[row]) {
                        updateTrackUI(row);
                    }
                }
            }

            function updateTrackUI(rowIndex) {
                const track = state.tracks[rowIndex];
                document.getElementById(`effect-selector-${rowIndex}`).disabled = false;
                document.getElementById(`effect-selector-${rowIndex}`).value = track.activeEffect;
                document.getElementById(`track-label-${rowIndex}`).textContent = track.name;

                const previewBtn = document.getElementById(`preview-btn-${rowIndex}`);
                const startSlider = document.getElementById(`start-slider-${rowIndex}`);
                const endSlider = document.getElementById(`end-slider-${rowIndex}`);

                previewBtn.disabled = false;
                startSlider.disabled = false;
                endSlider.disabled = false;

                startSlider.max = track.buffer.duration;
                startSlider.value = track.trimStart;
                endSlider.max = track.buffer.duration;
                endSlider.value = track.trimEnd;

                ['X', 'Y', 'Z'].forEach(axis => {
                    const slider = document.getElementById(`pan${axis}-slider-${rowIndex}`);
                    slider.value = track[`pan${axis}`];
                });
                const sliderA = document.getElementById('fxA-' + rowIndex);
                sliderA.value = track.fxA;
                const sliderB = document.getElementById('fxB-' + rowIndex);
                sliderB.value = track.fxB;
            }

            function handleFXChange(rowIndex, A, value) {
                const track = state.tracks[rowIndex];
                if (!track) return;

                if (A) track.fxA = value;
                else track.fxB = value;

                updateTrackAudioChain(rowIndex);
            }

            function handlePanChange(rowIndex, axis, value) {
                const track = state.tracks[rowIndex];
                if (!track || !track.panner) return;

                track[`pan${axis}`] = value;

                const pannerProp = `position${axis}`;
                track.panner[pannerProp].setValueAtTime(value, audioContext.currentTime);
            }

            function handleTrimChange(rowIndex, type, value) {
                const track = state.tracks[rowIndex];
                const startSlider = document.getElementById(`start-slider-${rowIndex}`);
                const endSlider = document.getElementById(`end-slider-${rowIndex}`);

                if (type === 'start') {
                    if (value >= track.trimEnd) {
                        value = track.trimEnd - 0.01;
                        startSlider.value = value;
                    }
                    track.trimStart = value;
                } else {
                    if (value <= track.trimStart) {
                        value = track.trimStart + 0.01;
                        endSlider.value = value;
                    }
                    track.trimEnd = value;
                }
            }

            function setupEventListeners() {
                dom.playBtn.addEventListener('click', startSequencer);
                dom.pauseBtn.addEventListener('click', pauseSequencer);
                dom.stopBtn.addEventListener('click', stopSequencer);
                dom.downloadBtn.addEventListener('click', exportToWav);

                dom.tempoSlider.addEventListener('input', (e) => {
                    state.tempo = parseInt(e.target.value, 10);
                    e.target.title = state.tempo + " BPM";
                    dom.colsSlider.title = Math.round(state.numCols / state.tempo * 6000) / 100 + " secs";
                });
                dom.timeSignatureSlider.addEventListener('input', (e) => {
                    state.timeSignature = parseInt(e.target.value, 10);
                    e.target.title = state.timeSignature + "/4";
                    updateGrid();
                });
                dom.rowsSlider.addEventListener('input', (e) => {
                    state.numRows = parseInt(e.target.value, 10);
                    e.target.title = state.numRows + " tracks";
                    updateGrid();
                });
                dom.colsSlider.addEventListener('input', (e) => {
                    state.numCols = parseInt(e.target.value, 10);
                    e.target.title = Math.round(state.numCols / state.tempo * 6000) / 100 + " secs";
                    updateGrid();
                });
            }

            updateGrid();
            setupEventListeners();

            function loadSample(file, rowIndex) {
                const reader = new FileReader();
                reader.onload = (e) => processAudioBuffer(e.target.result, rowIndex, file.name);
                reader.readAsArrayBuffer(file);
            }

            async function handleRecordClick(rowIndex) {
                if (audioContext.state === 'suspended') await audioContext.resume();
                if (state.mediaRecorder && state.mediaRecorder.state === 'recording') {
                    if (state.recordingTrackIndex === rowIndex) state.mediaRecorder.stop();
                } else {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        startRecording(stream, rowIndex);
                    } catch (err) { alert("Η πρόσβαση στο μικρόφωνο είναι απαραίτητη."); }
                }
            }

            function startRecording(stream, rowIndex) {
                state.mediaRecorder = new MediaRecorder(stream);
                const audioChunks = [];
                state.mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                state.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    audioBlob.arrayBuffer().then(arrayBuffer => processAudioBuffer(arrayBuffer, state.recordingTrackIndex));
                    stream.getTracks().forEach(track => track.stop());
                    state.mediaRecorder = null;
                    updateRecordButtons(null);
                };
                state.mediaRecorder.start();
                state.recordingTrackIndex = rowIndex;
                updateRecordButtons(rowIndex);
            }

            function nextStep() {
                const quarterNoteTime = 60000 / state.tempo;
                state.grid.forEach((row, rowIndex) => {
                    if (row[state.currentStep] && state.tracks[rowIndex]) {
                        playSound(state.tracks[rowIndex]);
                    }
                });
                updatePlaybackHead(state.currentStep, (state.currentStep + 1) % state.numCols);
                state.currentStep = (state.currentStep + 1) % state.numCols;
                state.scheduler = setTimeout(nextStep, quarterNoteTime);
            }

            async function exportToWav() {
                if (!audioContext) { alert("Please play a sound first to initialize audio."); return; }

                const quarterNoteDuration = 60 / state.tempo;
                const loopDuration = state.numCols * quarterNoteDuration;
                const offlineCtx = new OfflineAudioContext({ numberOfChannels: 2, length: audioContext.sampleRate * loopDuration, sampleRate: audioContext.sampleRate });
                offlineCtx.listener.setPosition(0, 0, 5);

                const masterGain = offlineCtx.createGain();
                masterGain.gain.value = 2;
                masterGain.connect(offlineCtx.destination);

                for (let rowIndex = 0; rowIndex < state.grid.length; rowIndex++) {
                    const track = state.tracks[rowIndex];
                    if (!track) continue;

                    for (let col = 0; col < state.numCols; col++) {
                        if (state.grid[rowIndex][col]) {
                            const startTime = col * quarterNoteDuration;

                            const source = offlineCtx.createBufferSource(); source.buffer = track.buffer;
                            const gain = offlineCtx.createGain();
                            const panner = offlineCtx.createPanner();
                            panner.panningModel = 'HRTF';
                            panner.positionX.value = track.panX; panner.positionY.value = track.panY; panner.positionZ.value = track.panZ;

                            source.connect(gain);
                            let lastNodeInChain = gain;

                            const effect = track.effects[track.activeEffect];
                            if (track.activeEffect !== 'no-fx' && effect) {
                                let effectNode;
                                switch (track.activeEffect) {
                                    case 'delay':
                                    case 'flanger':
                                        const isDelay = track.activeEffect === 'delay';
                                        effectNode = offlineCtx.createDelay(1.0);
                                        effectNode.delayTime.value = isDelay ? track.fxA / 100 : track.fxA / 10000;
                                        const feedback = offlineCtx.createGain();
                                        feedback.gain.value = isDelay ? track.fxB / 100 : track.fxB / 100;
                                        effectNode.connect(feedback).connect(effectNode);
                                        if (!isDelay) {
                                            const lfo = offlineCtx.createOscillator();
                                            lfo.type = 'sine'; lfo.frequency.value = 0.5;
                                            const lfoGain = offlineCtx.createGain();
                                            lfoGain.gain.value = 0.005;
                                            lfo.connect(lfoGain).connect(effectNode.delayTime);
                                            lfo.start(startTime); lfo.stop(startTime + loopDuration);
                                        }
                                        lastNodeInChain.connect(panner);
                                        lastNodeInChain.connect(effectNode);
                                        effectNode.connect(panner);
                                        break;
                                    case 'tremolo':
                                        effectNode = offlineCtx.createGain();
                                        const lfo = offlineCtx.createOscillator();
                                        lfo.type = 'sine';
                                        lfo.frequency.value = track.fxA / 20;
                                        const lfoGain = offlineCtx.createGain();
                                        lfoGain.gain.value = track.fxB / 100;
                                        lfo.connect(lfoGain).connect(effectNode.gain);
                                        lfo.start(startTime); lfo.stop(startTime + loopDuration);
                                        lastNodeInChain.connect(effectNode);
                                        lastNodeInChain = effectNode;
                                        break;
                                    default:
                                        if (track.activeEffect === 'reverb') {
                                            effectNode = offlineCtx.createConvolver();
                                            const impulseBuffer = offlineCtx.createBuffer(2, offlineCtx.sampleRate * track.fxA / 10, offlineCtx.sampleRate);
                                            for (let c = 0; c < 2; c++) {
                                                const chan = impulseBuffer.getChannelData(c);
                                                for (let i = 0; i < chan.length; i++) { chan[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / chan.length, 2); }
                                            }
                                            effectNode.buffer = impulseBuffer;
                                            masterGain.gain.value *= track.fxB / 50.0;
                                        }
                                        else if (track.activeEffect === 'distortion') {
                                            effectNode = offlineCtx.createWaveShaper();
                                            const curve = new Float32Array(22050);
                                            for (let i = 0; i < 22050; i++) {
                                                const x = i * 2 / 22050 - 1; curve[i] = (Math.PI + track.fxA * 5 * x) / (Math.PI + track.fxA * 5 * Math.abs(x)) * x;
                                            }
                                            effectNode.curve = curve;
                                            masterGain.gain.value *= track.fxB / 100.0;
                                        }
                                        else {
                                            effectNode = offlineCtx.createBiquadFilter();
                                            effectNode.type = 'bandpass';
                                            effectNode.frequency.value = track.fxA * 100;
                                            masterGain.gain.value *= track.fxB / 50.0;
                                        }
                                        lastNodeInChain.connect(effectNode);
                                        lastNodeInChain = effectNode;
                                        break;
                                }
                            }

                            if (track.activeEffect !== 'delay' && track.activeEffect !== 'flanger') {
                                lastNodeInChain.connect(panner);
                            }
                            panner.connect(masterGain);

                            const offset = track.trimStart; const duration = track.trimEnd - track.trimStart;
                            if (duration > 0) { source.start(startTime, offset, duration); }
                        }
                    }
                }

                const renderedBuffer = await offlineCtx.startRendering();
                const wavBlob = bufferToWav(renderedBuffer);
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = 'sequencer-loop.wav';
                document.body.appendChild(a); a.click();
                URL.revokeObjectURL(url); document.body.removeChild(a);
            }

            function startSequencer() { if (audioContext.state === 'suspended') { audioContext.resume(); } if (state.isPlaying) return; state.isPlaying = true; dom.playBtn.disabled = true; dom.pauseBtn.disabled = false; state.currentStep = state.currentStep > 0 ? state.currentStep : (state.numCols - 1); nextStep(); }
            function pauseSequencer() { if (!state.isPlaying) return; state.isPlaying = false; dom.playBtn.disabled = false; dom.pauseBtn.disabled = true; clearTimeout(state.scheduler); }
            function stopSequencer() { state.isPlaying = false; dom.playBtn.disabled = false; dom.pauseBtn.disabled = true; clearTimeout(state.scheduler); updatePlaybackHead(state.currentStep, -1); state.currentStep = 0; }
            function updatePlaybackHead(oldStep, newStep) { for (let row = 0; row < state.numRows; row++) { if (state.cells[row] && state.cells[row][oldStep]) { state.cells[row][oldStep].classList.remove('playback-head'); } if (newStep !== -1 && state.cells[row] && state.cells[row][newStep]) { state.cells[row][newStep].classList.add('playback-head'); } } }
            function updateRecordButtons(recordingIndex) { for (let i = 0; i < state.numRows; i++) { const btn = document.getElementById(`record-btn-${i}`); if (btn) { if (recordingIndex === null) { btn.disabled = false; btn.style.color = 'white'; btn.classList.remove('recording'); } else if (i === recordingIndex) { btn.disabled = false; btn.style.color = 'firebrick'; btn.classList.add('recording'); } else { btn.disabled = true; } } } }
            function bufferToWav(buffer) { const numOfChan = buffer.numberOfChannels, length = buffer.length * numOfChan * 2 + 44, bufferWav = new ArrayBuffer(length), view = new DataView(bufferWav), channels = []; let i, sample, pos = 0; function writeString(view, offset, string) { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } } writeString(view, pos, 'RIFF'); pos += 4; view.setUint32(pos, length - 8, true); pos += 4; writeString(view, pos, 'WAVE'); pos += 4; writeString(view, pos, 'fmt '); pos += 4; view.setUint32(pos, 16, true); pos += 4; view.setUint16(pos, 1, true); pos += 2; view.setUint16(pos, numOfChan, true); pos += 2; view.setUint32(pos, buffer.sampleRate, true); pos += 4; view.setUint32(pos, buffer.sampleRate * 2 * numOfChan, true); pos += 4; view.setUint16(pos, numOfChan * 2, true); pos += 2; view.setUint16(pos, 16, true); pos += 2; writeString(view, pos, 'data'); pos += 4; view.setUint32(pos, length - pos - 4, true); pos += 4; for (i = 0; i < buffer.numberOfChannels; i++) { channels.push(buffer.getChannelData(i)); } let offset = 0; while (pos < length) { for (i = 0; i < numOfChan; i++) { sample = Math.max(-1, Math.min(1, channels[i][offset])); sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; view.setInt16(pos, sample, true); pos += 2; } offset++; } return new Blob([view], { type: 'audio/wav' }); }

        });
    </script>
</body>

</html>
